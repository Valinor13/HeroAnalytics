from google.cloud import firestore
from google.cloud import language_v1
from google.cloud import speech
from google.cloud import storage
import json


# Entrypoint
def main(event, context):
    """Triggered by a change to a Cloud Storage bucket.
    Args:
         event (dict): Event payload.
         context (google.cloud.functions.Context): Metadata for the event.
    """
    file = event
    bucket_name = file['bucket']
    blob_name = file['name']
    print(f'Processing file: {blob_name} in bucket: {bucket_name}')
    print(event)

    if file['name'].endswith('.json'):
        # Get data from the newly uploaded file
        data = get_data(bucket_name, blob_name)
        print(data)

        # Transcribe encoded .wav file
        encoded = data['encoding']
        sst_data = transcribe(encoded)
        transcription = sst_data['transcription']
        print(f'Transcription: {transcription}')

        # Get sentiment of transcription
        sentiment = analyze_sentiment(transcription)
        print(sentiment)

        # Update json with new data and remove long encoded string to 
        # reduce file size to < 1mb
        update_json(data, sst_data | sentiment)
        print('Successfully updated JSON data')

        # Store in FireStore DB
        add_to_firestore(data)
        print('Successfully stored in Firestore')

        # Remove json file from bucket
        delete_blob(bucket_name, blob_name)
        print('JSON file removed from bucket')


def get_count(collection):
    """Gets the count of no. documents within a collection from the document titled "count".
    It also updates the count stored in the document. Used for auto incrementing userIDs.
    Args:
        collection (str): the name of the collection where the "count" document is
    Returns:
        count (int): the value returned from the "count" document
    """
    db = firestore.Client()
    doc_ref = db.collection('counts').document(collection)
    doc = doc_ref.get().to_dict()
    count = doc['count']
    new_count = count + 1
    doc = {'count': new_count}
    doc_ref.set(doc)

    return count


def get_data(bucket_name, blob_name):
    """Retrieves the data from the new blob (file) in the bucket
    Args:
        bucket_name (str): name of bucket where blob is located
        blob_name (str): name of blob to find
    Returns:
        data (dict): the retrieved data
    """
    storage_client = storage.Client()
    bucket = storage_client.get_bucket(bucket_name)
    blob = bucket.blob(blob_name)
    data = json.loads(blob.download_as_string(client=None))

    return data


def delete_blob(bucket_name, blob_name):
    """Deletes a blob (file) from the bucket.
    Args:
        bucket_name (str): name of bucket where blob is located
        blob_name (str): name of blob to delete
    """
    storage_client = storage.Client()
    bucket = storage_client.bucket(bucket_name)
    blob = bucket.blob(blob_name)
    blob.delete()


def add_to_firestore(data):
    """Adds a document to a Firestore collection.
    The documents name will be automatically generated by Firestore
    Args:
        data (str): the document to add
        collection (str): the collection to add the document to
    """
    db = firestore.Client()
    collection = data['collection']
    db.collection(collection).add(data)


def update_json(data, sst_data):
    """Updates the JSON file within the bucket
    Args:
        data (dict): the json dictionary
        transcription (str): the transcription of the audio file
        sentiment (dict): key/value pairs associated with sentiment analysis
        count (int): the integer to assign to userID for Firestore
    """
    data.pop('encoding')
    collection = data['collection']
    count = get_count(collection)
    data['userID'] = count
    data.update(sst_data)


def transcribe(encoded):
    """Transcribes base64 encoded audio.
    Args:
        encoded (str): the base64 encoded .wav file
    Returns:
        transcription (str): the transcription of the audio file
    """
    sst_data = {}

    try:
        client = speech.SpeechClient()
        audio = speech.RecognitionAudio(content=encoded)
        config = speech.RecognitionConfig(
            language_code="en-US",
            enable_automatic_punctuation=True,
            audio_channel_count=1
        )

        response = client.recognize(config=config, audio=audio)
        transcription = ''

        for i, result in enumerate(response.results):
            if i == (len(response.results) - 1):
                transcription += result.alternatives[0].transcript
            else:
                transcription += result.alternatives[0].transcript + ' '
        
        sst_data['transcription'] = transcription
        sst_data['confidence'] = response.results[0].alternatives[0].confidence
    
    except Exception as e:
        print(f'Failed to transcribe audio:\n{e}')
        sst_data['transcription'] = ''
        sst_data['confidence'] = 0.0

    return sst_data


def analyze_sentiment(transcription):
    """Analyzes the sentiment of a transcribed audio file.
    Args:
        transcription (str): the transcription to analyze
    Returns:
        sentiment (dict): dictionary containing sentiment values
            * score (float): score between -1.0 and 1.0 - determines positive/negative feelings
                * Between -1.0 and 1.0
                * Overall emotion of the text
                * Closer to -1.0 indicates negative emotion, closer to 1.0 indicates positive
            * magnitude (float): determines strength of emotion within the document (transcribed voice recording)
                * Determines the strenth of the emotion
                * Always > 0
                * Further from 0 indicates stronger emotion
            * analyzed_sentiment (str): 'negative', 'neutral', 'positive'
    """
    if transcription:
        client = language_v1.LanguageServiceClient()
        document = language_v1.Document(
            content=transcription, type_=language_v1.Document.Type.PLAIN_TEXT
        )
        annotations = client.analyze_sentiment(request={'document': document})

        sentiment = {}

        magnitude = annotations.document_sentiment.magnitude
        score = annotations.document_sentiment.score
        
        if -1.0 < score < -0.32:
            analyzed_sentiment = 'neutral' # negative
        elif -0.32 < score < 0.3:
            analyzed_sentiment = 'neutral'
        elif 0.3 < score < 0.8:    
            analyzed_sentiment = 'positive'
        else:
            analyzed_sentiment = 'ecstatic'
    else:
        score = None
        magnitude = None
        analyzed_sentiment = None

    sentiment['score'] = score
    sentiment['magnitude'] = magnitude
    sentiment['analyzed_sentiment'] = analyzed_sentiment

    return sentiment
